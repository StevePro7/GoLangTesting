Google I/O 2012
07-Nov-2023

https://www.youtube.com/watch?v=f6kdp27TYZs

A lot of independently executing things
independent agents

concurrency:
writing or structuring to deal with the real world

definition of concurrency
composition of independently executing computations [goroutines]

a way to structure software to write clean code that interacts well with real world

concurrency is NOT parallelism although is enables parallelism

one processor: program can be concurrent but it cannot be parallel
well-written concurrent program may run efficiently in parallel on multiprocessor


Concurrency is a model for software construction
- easy to understand
- easy to use
- easy to reason about
- nicer than dealing with parallelism	[threads, semaphores, locks, barriers]


1978
Hoare CSP
Communicating Sequential Processes
https://www.cs.cmu.edu/~crary/819-f09/Hoare78.pdf


Go don't talk to a process but a channel


CODE

goroutine
launching a shell command with &

goroutine
independently executing function
launched by go statement
has its own stack	grows / shrinks
very cheap		[think cheap thread]
NOT a thread
may be 1x thread with 000s goroutines
goroutines multiplexed dynamically onto threads created as needed


communication
channel in Go provides a connectio between two goroutines
allowing them to communicate


direction
arrow points in the direction in which the channel is sending data

c <- 1		send	1 is pointing into the channel
value = <-c	recd 	arrow is point out of the channel


synchronization
function executes <-c		it will wait for value to be send
function executes c <- value	it waits for receiver to be ready

sender + receiver must both be ready to play part in communcation
otherwise we wait until they are	[can deadlock otherwise]

channels both communicate and synchronize

when you read from a channel you have to wait for a value to be there
it's a blocking operation

when you send a value on a channel, the channel blocks until someone is ready to receive it
it's a blocking operation

channels communicate and synchronize in a single operation



BUFFERED channels
buffering removes synchronization
buffering makes them more like Erlang's mailboxes
buffering can be important for some problems but more subtle to reason about

buffered channels have property that they don't synchronize when you send
because you can just drop a value in the buffer and keep going


IMPORTANT
don't communicate by sharing memory rather share memory by communicating

use the channel to pass the data back n' forth btwn the goroutines
make your concurrent program operate that way


Patterns

01. Generator
function that returns a channel

e.g.
func boring(msg string) <-chan string
return value is a channel that you can only receive from

because the caller is only going to use it as a received value
<-c

generator returns a channel back to the caller the channel with
which to communicate to the process that's running that goroutine


02. Service
channels as a handle on a service
function returns a channel that lets us communicate with the service it provides
can have more instances of the service